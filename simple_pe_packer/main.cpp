#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <boost/scoped_array.hpp>
#include <boost/program_options.hpp>
#include <boost/timer.hpp>
//PE library header file 
#include "pe_bliss.h"
#include "pe_bliss_resources.h"
//LZO1Z999 algorithm header file
#include "lzo/lzo1z.h"
//Our structures header file
#include "structs.h"
//Header file with unpacker parameters
#include "../unpacker/parameters.h"
//Unpacker body (autogenerated)
#include "unpacker.h"

using namespace pe_bliss;

#if _MSC_VER
// C4244: conversion from 'std::streamoff' to 'uint32_t', possible loss of data.
#pragma warning(disable: 4244)
#endif

//PE and LZO libraries linking directives
#ifndef _M_X64
#ifdef _DEBUG
#pragma comment(lib, "../pelib/pe_bliss_d.lib")
#pragma comment(lib, "../Debug/lzo-2.10.lib")
#else
#pragma comment(lib, "../pelib/pe_bliss.lib")
#pragma comment(lib, "../Release/lzo-2.10.lib")
#endif
#else
#ifdef _DEBUG
#pragma comment(lib, "../pelib/x64/Debug/pe_bliss.lib")
#pragma comment(lib, "../x64/Debug/lzo-2.10.lib")
#else
#pragma comment(lib, "../pelib/x64/Release/pe_bliss.lib")
#pragma comment(lib, "../x64/Release/lzo-2.10.lib")
#endif
#endif

int main(int argc, char* argv[])
{
	//To use short namespace alias
	namespace po = boost::program_options;

	//Timer counts the time
	//required for packing
	boost::timer pack_timer;

	//Forced packing - even potentially incorrect file
	//will be packed
	bool force_mode = false;
	//Decompress mode 
	bool decompress_mode = false;
	//Whether resources should be packed
	bool repack_resources;
	//Whether loading configuration directory should be packed
	bool rebuild_load_config;
	//Whether DOS header should be stripped
	bool strip_dos_headers;
	//File alignment after packing
	unsigned long file_alignment;

	//Path to source file
	std::string input_file_name;
	//Path to packed file
	std::string output_file_name;

	//File data
	std::string file_data;
	//File size
	uint32_t file_size;


	//Create options description
	po::options_description visible_options("DXPack Packer 1.1\nCommand Line Options");

	try
	{
		//Create allowed options list
		//Add default values (not for all of them)
		po::options_description cmdline;

		//out-file,o - means that option name is "--out-file"
		//and its short alias is "-o"
		visible_options.add_options()
			("out-file,o", po::value<std::string>(&output_file_name), "Output file name")
			("file-align,a", po::value<unsigned long>(&file_alignment)->default_value(512), "Packed file alignment")
			("strip-dos,s", po::value<bool>(&strip_dos_headers)->default_value(false), "Strip DOS headers")
			("repack-res,r", po::value<bool>(&repack_resources)->default_value(true), "Repack resources")
			("build-load-config,l", po::value<bool>(&rebuild_load_config)->default_value(true), "Rebuild Load Config directory")
			("force,f", "Force packing of possibly incorrect binaries")
			("decompress,d", "Decompress the packed file")
			;

		cmdline.add(visible_options);
		//Hidden option - name of the file to pack
		cmdline.add_options()
			("image", po::value<std::string>(&input_file_name), "PE image to pack")
			;    

		//Unnamed (name of the file to pack should go first)
		po::positional_options_description desc_pos;
		desc_pos.add("image", 1);

		//Parse the command line
		po::variables_map vm;
		po::store(po::command_line_parser(argc, argv).
		options(cmdline).positional(desc_pos).run(), vm);
		po::notify(vm);

		//If the path to source file is not specified
		if(input_file_name.empty())
			throw std::runtime_error("No input file specified");

		//If forced packing mode is specified
		if(vm.count("force"))
		{
			std::cout << "Force mode is active!" << std::endl;
			force_mode = true;
		}
		//If decompress mode is specified
		if (vm.count("decompress"))
		{
			std::cout << "decompress mode is active!" << std::endl;
			decompress_mode = true;
		}
	}
	catch(const std::exception& e)
	{
		//If something went wrong - output options description
		std::cout << e.what() << std::endl << std::endl;
		std::cout << visible_options << std::endl;
		system("pause");
		return 0;
	}
	std::string stmp = decompress_mode ? "Unpacking " : "Packing ";
	std::cout << stmp << input_file_name << std::endl;
	//Open a file
	std::auto_ptr<std::ifstream> file;
	file.reset(new std::ifstream(input_file_name, std::ios::in | std::ios::binary));
	if(!*file)
	{
		//If the file was not opened successfully - notify user and exit with error
		std::cout << "Cannot open " << input_file_name << std::endl;
		return -1;
	}

	try
	{
		//Try to open the file as 32-bit PE file
		//Last two arguments are false, because we don't need them
		//"raw" file bound import data and 
		//"raw" debug information data
		//They are not used while packing, so we don't load these data
		pe_base image(*file, pe_properties_32(), false);
		if (!decompress_mode) // Only need for packer
		{
			//Read the file data before reset it 
			(*file).seekg(0, std::ios::beg);
			(*file).seekg(0, std::ios::end);
			file_size = (*file).tellg();
			(*file).seekg(0, std::ios::beg);
			file_data.resize(file_size);
			(*file).read(&file_data[0], file_size);
		}
		file.reset(0); //Close file and free memory

		//Check if .NET image was passed
		if(image.is_dotnet() && !force_mode)
		{
			std::cout << ".NET image cannot be packed!" << std::endl;
			return -1;
		}
		if (decompress_mode)
		{
			//PE file section
			const section& first_section = image.get_image_sections().front();
			if (first_section.get_name().compare(".SPP1"))
			{
				std::cout << "Unknow packed file!" << std::endl;
				return -1;
			}
			std::string section_data = first_section.get_raw_data();
			//Get pointer to structure with information
			//carefully prepared by packer
			const packed_file_info* info;
			//It is stored in the beginning
			//of packed file first section
			info = reinterpret_cast<const packed_file_info*>(section_data.data());
			//Pointer to the memory 
			//to store unpacked data
			LPVOID unpacked_mem;
			//Allocate the memory
			unpacked_mem = VirtualAlloc(
				0,
				info->size_of_unpacked_data,
				MEM_COMMIT,
				PAGE_READWRITE);
			//Unpacked data size
			lzo_uint out_len;
			out_len = 0;

			//Unpack with LZO algorithm
			lzo1z_decompress(
				reinterpret_cast<const unsigned char*>(reinterpret_cast<DWORD>(info) + sizeof(packed_file_info)),
				info->size_of_packed_data,
				reinterpret_cast<unsigned char*>(unpacked_mem),
				&out_len,
				0);

			std::string base_file_name;

			if (output_file_name.empty())
			{
				//Create new PE file
				//Get the name of original file without directory
				base_file_name = input_file_name;
				std::string dir_name;
				std::string::size_type slash_pos;
				if ((slash_pos = base_file_name.find_last_of("/\\")) != std::string::npos)
				{
					dir_name = base_file_name.substr(0, slash_pos + 1); //Source file directory
					base_file_name = base_file_name.substr(slash_pos + 1); //Source file name
				}

				//Give a name to a new file: "packed_" + original_file_name
				//Concatenate it with original directory name to save it to a folder where
				//original file is stored
				base_file_name = dir_name + "unpacked_" + base_file_name;
			}
			else
			{
				base_file_name = output_file_name;
			}

			//Create file
			std::ofstream new_pe_file(base_file_name.c_str(), std::ios::out | std::ios::binary | std::ios::trunc);
			if (!new_pe_file)
			{
				//If failed to create file - display an error message
				std::cout << "Cannot create " << base_file_name << std::endl;
				return -1;
			}
			new_pe_file.write(reinterpret_cast<const char*>(unpacked_mem), out_len);
			new_pe_file.close();
			VirtualFree(unpacked_mem, out_len, MEM_RELEASE);

			return 0;
		}
		
		//Calculate file sections entropy to make sure that file was not packed
		{
			std::cout << "Entropy of sections: ";
			double entropy = entropy_calculator::calculate_entropy(image);
			std::cout << entropy << std::endl;
			//There is an opinion,
			//that PE files have normal entropy below 6.8
			//If it has more, than file is most possibly compressed
			//So (for now) we will not pack files
			//with high entropy, this makes little sense
			if(entropy > 6.8)
			{
				std::cout << "File has already been packed!" << std::endl;
				if(!force_mode)
					return -1;
			}
		}

		//Initialize LZO compression library
		if(lzo_init() != LZO_E_OK)
		{
			std::cout << "Error initializing LZO library" << std::endl;
			return -1;
		}
		
		std::cout << "Reading sections..." << std::endl;

		//Get PE file sections list
		const section_list& sections = image.get_image_sections();
		if(sections.empty())
		{
			//If file has no sections, we have nothing to pack
			std::cout << "File has no sections!" << std::endl;
			return -1;
		}

		//PE file basic information structure
		packed_file_info basic_info = {0};

		//New section
		section new_section;
		//Name - .rsrc (see description below)
		new_section.set_name(".SPP1");
		//Available for reading, writing, execution
		new_section.readable(true).writeable(true).executable(true);
		//Reference to section raw data
		std::string& out_buf = new_section.get_raw_data();

		//Create smart pointer
		//and allocate memory required by LZO algorithm
		//Smart pointer will release this memory
		//automatically if needed
		//We use lzo_align_t type to
		//align memory as required
		//(from LZO documentation)
		boost::scoped_array<lzo_align_t> work_memory(new lzo_align_t[LZO1Z_999_MEM_COMPRESS]);
		
		//Unpacked data length
		lzo_uint src_length = file_size;
		//Save it to our file information structure
		basic_info.size_of_unpacked_data = src_length;
		
		//Packed data length
		//(unknown yet)
		lzo_uint out_length = 0;
		
		//Compressed data buffer
		//(length based on LZO documentation recommendations)
		out_buf.resize(src_length + src_length / 16 + 64 + 3);

		//Perform data compression
		std::cout << "Packing data..." << std::endl;
		if(LZO_E_OK !=
			lzo1z_999_compress(reinterpret_cast<const unsigned char*>(file_data.data()),
			src_length,
			reinterpret_cast<unsigned char*>(&out_buf[0]),
			&out_length,
			work_memory.get())
			)
		{
			//If something goes wrong, exit
			std::cout << "Error compressing data!" << std::endl;
			return -1;
		}
		
		std::cout << "Packing complete..." << std::endl;

		//Store packed data length in our structure
		basic_info.size_of_packed_data = out_length;
		//Resize output buffer with compressed data by
		//resulting compressed data length
		//which is now known
		out_buf.resize(out_length);
		//Assemble the buffer, this will be
		//resulting data of our new section
		out_buf =
			//basic_info structure data
			std::string(reinterpret_cast<const char*>(&basic_info), sizeof(basic_info))
			//Output buffer
			+ out_buf;

		//Check if file became really smaller
		if(out_buf.size() >= src_length)
		{
			std::cout << "File is incompressible!" << std::endl;
			if(!force_mode)
				return -1;
		}
		
		//If the file has TLS, we get information about it
		std::unique_ptr<tls_info> tls;
		if (image.has_tls())
		{
			std::cout << "Reading TLS..." << std::endl;
			tls.reset(new tls_info(get_tls_info(image)));
		}
		//If a file has exports, get information about them
		//and list them
		exported_functions_list exports;
		export_info exports_info;
		if (image.has_exports())
		{
			std::cout << "Reading exports..." << std::endl;
			exports = get_exported_functions(image, exports_info);
		}

		{
			//Get reference to first existing 
			//PE file section
			const section& first_section = image.get_image_sections().front();
			//Set virtual address of section to be added (see below)
			new_section.set_virtual_address(first_section.get_virtual_address());

			//Get reference to last existing PE file
			//section
			const section& last_section = image.get_image_sections().back();
			//Calculate total virtual data size
			DWORD total_virtual_size = 
				//Last section virtual address
				last_section.get_virtual_address()
				//Aligned last section virtual size
				+ pe_utils::align_up(last_section.get_virtual_size(), image.get_section_alignment())
				//Subtract first section size
				- first_section.get_virtual_address();
			//FIXME: Maybe -f ,I don't know
			total_virtual_size = pe_utils::align_up<DWORD>( max(total_virtual_size, out_buf.size()), image.get_section_alignment() );
			
			//Delete all PE file sections, except resource section
			//FIXME : resource section
			image.get_image_sections().clear();

			//Change file alignment
			image.realign_file(file_alignment);

			//Add our section and get reference to
			//already added section with recalculated addresses and sizes
			section& added_section = image.add_section(new_section);
			//Set required virtual size for it
			image.set_section_virtual_size(added_section, total_virtual_size);
			
			
			std::cout << "Creating imports..." << std::endl;

			//Create kernel32.dll library imports
			import_library kernel32;
			kernel32.set_name("kernel32.dll"); //Set library name

			//Create function to import
			imported_function func;
			func.set_name("LoadLibraryA"); //Its name
			kernel32.add_import(func); //Add it to the library

			//And second function
			func.set_name("GetProcAddress");
			kernel32.add_import(func); //Add it, too
									   
			//And third function
			func.set_name("FreeLibrary");
			kernel32.add_import(func); //Add it, too

			//Get load_library_a field relative address (RVA)
			//of our packed_file_info structure, which was placed at the beginning of 
			//added section, remember?
			DWORD load_library_address_rva = pe_base::rva_from_section_offset(added_section,
				offsetof(packed_file_info, load_library_a));

			//Set this address as
			//import address table (IAT) address
			kernel32.set_rva_to_iat(load_library_address_rva);

			//Create imported library list
			imported_functions_list imports;
			//Add our library to it
			imports.push_back(kernel32);

			//Set up import rebuilder
			import_rebuilder_settings settings;
			//We don't need original import address table (explanations will be given further) 
			settings.build_original_iat(false);
			//Rewrite IAT to the address
			//which was specified (load_library_address_rva)
			settings.save_iat_and_original_iat_rvas(true, true);
			//Place imports right after packed data end
			settings.set_offset_from_section_start(added_section.get_raw_data().size());
			//disable automatic section stripping
			//after adding imports to it
			settings.enable_auto_strip_last_section(false);

			//Rebuild imports
			rebuild_imports(image, imports, added_section, settings);

			//If the file has TLS
			if (tls.get())
			{
				//Pointer to our packer information structure
				//This structure is in the beginning of new added section,
				//we added it a bit earlier
				packed_file_info* info = reinterpret_cast<packed_file_info*>(&added_section.get_raw_data()[0]);

				//Write original TLS
				//relative virtual address
				info->original_tls_index_rva = tls->get_index_rva();

				//If we have TLS callbacks, write
				//relative virtual address of their array in original file
				//to structure
				if (!tls->get_tls_callbacks().empty())
					info->original_rva_of_tls_callbacks = tls->get_callbacks_rva();

				//Now the relative virtual address of TLS index
				//will change - we will make the loader to write it to tls_index field
				//of packed_file_info structure
				tls->set_index_rva(pe_base::rva_from_section_offset(added_section, offsetof(packed_file_info, tls_index)));
			}					
		}
		
		//It is necessary to reserve place for
		//original TLS callbacks
		//plus one cell for zero DWORD
		DWORD first_callback_offset = 0;

		{
			//New section for unpacker code etc.
			section unpacker_section;
			//name - coderpub
			unpacker_section.set_name(".SPP2"); //Simple PE Packer
			//Available for reading and execution 
			unpacker_section.readable(true).executable(true).writeable(true);
			
			{
				std::cout << "Writing unpacker stub, size = " << sizeof(unpacker_data) << " bytes" << std::endl;
				//Get a reference to unpacker section data
				std::string& unpacker_section_data = unpacker_section.get_raw_data();
				//Write unpacker code there
				//This code is stored in autogenerated file
				//unpacker.h, which we included in main.cpp
				unpacker_section_data = std::string(reinterpret_cast<const char*>(unpacker_data), sizeof(unpacker_data));
				//and first packed file section virtual address,
				//which stores data to unpack and information about them
				//At the beginning of this section, as you remember, 
				//packed_file_info structure is stored
				*reinterpret_cast<DWORD*>(&unpacker_section_data[rva_of_first_section_offset]) = image.get_image_sections().at(0).get_virtual_address();
				//Write image load address 
				//to required offsets
				*reinterpret_cast<DWORD*>(&unpacker_section_data[original_image_base_offset]) = image.get_image_base_32();
			}

			//Add this section too
			section& unpacker_added_section = image.add_section(unpacker_section);
			
			{
				//Change the unpacker section data size precisely
				//by the number of bytes in the unpacker body
				//(in case that null bytes from the end were stripped by
				//PE library)
				unpacker_added_section.get_raw_data().resize(sizeof(unpacker_data));
			}
			//If file has TLS
			if (tls.get())
			{
				std::cout << "Rebuilding TLS..." << std::endl;

				//Reference to unpacker raw section data
				//Only unpacker body is located there yet
				std::string& data = unpacker_added_section.get_raw_data();

				//Calculate the position to write IMAGE_TLS_DIRECTORY32 structure
				DWORD directory_pos = data.size();
				//Allocate space for this structure
				//sizeof(DWORD) is required for alignment, because
				//IMAGE_TLS_DIRECTORY32 must be aligned to 4-byte boundary
				data.resize(data.size() + sizeof(IMAGE_TLS_DIRECTORY32) + sizeof(DWORD));

				//If TLS has callbacks...
				if (!tls->get_tls_callbacks().empty())
				{
					size_t num_callback = tls->get_tls_callbacks().size();
					//It is necessary to reserve memory
					//for original TLS callback addresses
					//Plus 1 cell for null DWORD
					first_callback_offset = data.size();
					data.resize(data.size() + sizeof(DWORD) * (num_callback + 1));

					//First callback will be our empty one (ret 0xC),
					//Write its address, FIXME: if have more than one callback?
					uint32_t empty_tls_callback = image.rva_to_va_32(pe_base::rva_from_section_offset(unpacker_added_section, empty_tls_callback_offset));
					DWORD* new_callback = reinterpret_cast<DWORD*>(&data[first_callback_offset]);
					for (size_t i = 0; i < num_callback; i++, ++new_callback)
					{
						*new_callback = empty_tls_callback;
					}
					*new_callback = 0;

					//Write relative virtual address
					//of new TLS callbacks table
					tls->set_callbacks_rva(pe_base::rva_from_section_offset(unpacker_added_section, first_callback_offset));

					//Now write new callbacks table relative address
					//to packed_file_info structure, which is placed at
					//the beginning of first section
					reinterpret_cast<packed_file_info*>(&image.get_image_sections().at(0).get_raw_data()[0])->new_rva_of_tls_callbacks = tls->get_callbacks_rva();
				}
				else
				{
					//If no callbacks exist, let's set address to null just in case
					tls->set_callbacks_rva(0);
				}

				//Clean up callback array, we don't need them anymore
				//We created them manually
				tls->clear_tls_callbacks();

				//Set new relative address
				//of data used to initialize thread local memory
				tls->set_raw_data_start_rva(pe_base::rva_from_section_offset(unpacker_added_section, data.size()));
				//Recalculate the address of these data end
				tls->recalc_raw_data_end_rva();

				//Rebuild TLS
				//Notify the rebuilder, that it is not needed to write data and callbacks
				//We do this manually (callbacks are already written to the right places)
				//Also we indicate that we don't need to strip null bytes at the end of the section
				rebuild_tls(image, *tls, unpacker_added_section, directory_pos, false, false, tls_data_expand_raw, true, false);

				//Add data used to initialize local thread memory to the section
				unpacker_added_section.get_raw_data() += tls->get_raw_data();
				//Now set "coderpub" section virtual size
				//taking into account SizeOfZeroFill of TLS field
				image.set_section_virtual_size(unpacker_added_section, data.size() + tls->get_size_of_zero_fill());
				//At last, strip unnecessary null bytes at the end of the section
				//if (!image.has_reloc() && !image.has_exports() && !load_config.get())
					//pe_utils::strip_nullbytes(unpacker_added_section.get_raw_data());
				//and recalculate its sizes (raw and virtual)
				image.prepare_section(unpacker_added_section);
			}

						
			//Set new entry point - now it points to
			//the beginning of unpacker
			image.set_ep(image.rva_from_section_offset(unpacker_added_section, 0));
			std::string& unpacker_section_data = unpacker_added_section.get_raw_data();
		}

		if (image.has_reloc())
		{
			std::cout << "Creating relocations..." << std::endl;

			//Create relocation table list and a table
			relocation_table_list reloc_tables;

			section& unpacker_section = image.get_image_sections().at(1);

			{
				relocation_table table;
				//Set relocation table virtual address
				//It will be equal to the relative virtual address of the second added
				//section, because it stores the unpacker code with the variable to fix
				table.set_rva(unpacker_section.get_virtual_address());

				//Add relocation by original_image_base_offset offset from
				//parameters.h file of the unpacker
				table.add_relocation(relocation_entry(original_image_base_offset, IMAGE_REL_BASED_HIGHLOW));

				//Add the table to the list
				reloc_tables.push_back(table);
			}

			//If a file has TLS
			if (tls.get())
			{
				//Calculate offset to TLS structure
				//relative to the beginning of second section
				DWORD tls_directory_offset = image.get_directory_rva(IMAGE_DIRECTORY_ENTRY_TLS)
					- image.section_from_directory(IMAGE_DIRECTORY_ENTRY_TLS).get_virtual_address();

				//Create new relocation table, as TLS table can be too far away
				//from original_image_base_offset. This can lead to relocation table addresses overflow
				relocation_table table;
				table.set_rva(image.get_directory_rva(IMAGE_DIRECTORY_ENTRY_TLS));
				//Add relocations for StartAddressOfRawData,
				//EndAddressOfRawData and AddressOfIndex fields
				//These fields are always not null
				table.add_relocation(relocation_entry(static_cast<WORD>(
					offsetof(IMAGE_TLS_DIRECTORY32, StartAddressOfRawData)), IMAGE_REL_BASED_HIGHLOW));
				table.add_relocation(relocation_entry(static_cast<WORD>(
					offsetof(IMAGE_TLS_DIRECTORY32, EndAddressOfRawData)), IMAGE_REL_BASED_HIGHLOW));
				table.add_relocation(relocation_entry(static_cast<WORD>(
					offsetof(IMAGE_TLS_DIRECTORY32, AddressOfIndex)), IMAGE_REL_BASED_HIGHLOW));

				//If TLS callbacks exist
				if (first_callback_offset)
				{
					//Add relocations for AddressOfCallBacks field
					//and for our empty callback address
					table.add_relocation(relocation_entry(static_cast<WORD>(offsetof(IMAGE_TLS_DIRECTORY32, AddressOfCallBacks)), IMAGE_REL_BASED_HIGHLOW));
					table.add_relocation(relocation_entry(static_cast<WORD>(tls->get_callbacks_rva() - table.get_rva()), IMAGE_REL_BASED_HIGHLOW));
				}

				reloc_tables.push_back(table);
			}

			//Rebuild relocations, placing them at the end
			//of section with the unpacker code
			rebuild_relocations(image, reloc_tables, unpacker_section, unpacker_section.get_raw_data().size(), true, !image.has_exports());
		}
		//
		if (image.has_exports())
		{
			std::cout << "Repacking exports..." << std::endl;

			section& unpacker_section = image.get_image_sections().at(1);

			//Rebuild exports and place them to "coderpub" section
			rebuild_exports(image, exports_info, exports, unpacker_section, unpacker_section.get_raw_data().size(), true);
		}

		//Delete all often used directories
		//we will return them further
		//and manage correctly, but that way for now
		//image.remove_directory(IMAGE_DIRECTORY_ENTRY_EXPORT);			//0
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_RESOURCE);			//2
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_EXCEPTION);		//3
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_SECURITY);			//4
		//image.remove_directory(IMAGE_DIRECTORY_ENTRY_BASERELOC);		//5
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_DEBUG);			//6
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_ARCHITECTURE);		//7
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_GLOBALPTR);		//8
		//image.remove_directory(IMAGE_DIRECTORY_ENTRY_TLS);				//9
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG);		//10
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT);		//11
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_IAT);				//12
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT);		//13
		image.remove_directory(IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR);	//14

		std::string base_file_name;

		if(output_file_name.empty())
		{
			//Create new PE file
			//Get the name of original file without directory
			base_file_name = input_file_name;
			std::string dir_name;
			std::string::size_type slash_pos;
			if((slash_pos = base_file_name.find_last_of("/\\")) != std::string::npos)
			{
				dir_name = base_file_name.substr(0, slash_pos + 1); //Source file directory
				base_file_name = base_file_name.substr(slash_pos + 1); //Source file name
			}

			//Give a name to a new file: "packed_" + original_file_name
			//Concatenate it with original directory name to save it to a folder where
			//original file is stored
			base_file_name = dir_name + "packed_" + base_file_name;
		}
		else
		{
			base_file_name = output_file_name;
		}
		
		//Create file
		std::ofstream new_pe_file(base_file_name.c_str(), std::ios::out | std::ios::binary | std::ios::trunc);
		if(!new_pe_file)
		{
			//If failed to create file - display an error message
			std::cout << "Cannot create " << base_file_name << std::endl;
			return -1;
		}

		//Rebuild PE image
		//Strip DOS header, writing NT headers over it
		//(second parameter (strip_dos_headers) is responsible for this)
		//Do not recalculate SizeOfHeaders - third parameter is responsible for this
		rebuild_pe(image, new_pe_file, strip_dos_headers, false);

		//Message user that file is successfully packed
		std::cout << "Packed image was saved to " << base_file_name << std::endl;
		
		std::cout << "Resulting sections entropy: " << entropy_calculator::calculate_entropy(image) << std::endl;
		std::cout << "Finished in " << pack_timer.elapsed() << " sec" << std::endl;
	}
	catch(const pe_exception& e)
	{
		//If the file was not opened by any reason
		//Display error message and exit
		std::cout << "Error: " << e.what() << std::endl;
		return -1;
	}

	return 0;
}
